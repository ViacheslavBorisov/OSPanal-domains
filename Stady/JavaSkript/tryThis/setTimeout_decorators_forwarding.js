// 1.setTimeout, setInterval
// 2. Декораторы, переадресация вызовов, call/aply

// 1. setTimeout, setInterval
// let timerId = setTimeout(() => console.log("ничего не происходит"), 1000);
// console.log(timerId); // идентификатор таймера
// clearTimeout(timerId);
// console.log(timerId); // тот же идентификатор (не принимает значение null после отмены, но некоторые свойства меняются)
// Вложенный таймаут - способ запустить что-то периодически ( как и сетИнтервал )
// вместо:
// let timerId = setInterval(() => console.log('tick'), 2000);
// clearInterval( timerId );
// Пишем рекурсивный вызов таймаута:
// let timerId = setTimeout(function tick() {
//     console.log('tick');              // во-первых, тикает.
//     timerId = setTimeout(tick, 2000); // во-вторых, рекурсивно вызывает саму себя через 2 с.- время до очередного старта
//   }, 2000);                           // время до первого старта.
// //setTimeout( () => { clearInterval( timerId ); console.log( 'stop ') }, 20000 ); // останавливаем процесс через 20 с.
// function reset() {
//     const str = prompt( 'Input password to stop :)' );
//     let stop = new Function( str );
//     stop();
// };
// setTimeout( reset, 30000 );setTimeout( () => { clearInterval( timerId ); console.log( 'stop ') }, 20000 )

// Задача 1. Напишите функцию printNumbers(from, to), которая выводит число каждую секунду, начиная от from и заканчивая to.
// Сделайте два варианта решения.
// Используя setInterval.
// Используя рекурсивный setTimeout.
// function printNumbers(from, to) { // use setInterval
//     let i = from;
//     let timerId = setInterval( () => console.log( i++ ), 1000 );
//     setTimeout( () => { clearInterval( timerId ); console.log( 'stop', to) }, ( to - from + 1 ) * 1000 );
// }
// function printNumbers(from, to) { // use setTimeout
//     let timerId;
//      setTimeout( function tickNum() { 
//             console.log( from++ );
//             timerId = setTimeout( tickNum, 1000 );            
//         }, 1000 );
//     setTimeout( () => { clearTimeout( timerId ); console.log( 'stop', to) }, ( to - from + 1 ) * 1000 );
// }
// printNumbers( 5, 11 );

// 2.Декораторы
// Декоратор - кэшератор. Пробую повторить за учебником...
// function wdf( x ) { // wdf - wery dificalt function
//     return x * x;
//   };
//   function casheRator( func ) { // get a function such input parametr
//     const cash = new Map;       // создаем в ЛО функции хранилище для кэша( если она такое уже считала, пусть будет там)
//     return function( arg ) {    // эта функция по сути исходная ф-я + некая логическая оболочка ( если че - бери из кэша)
//       if ( cash.has( arg ) ) {  // если такие исходные данные (arg) уже встречались, то результат не считаем, а берем из кэша.
//         console.log( ' From cash ' );
//         return cash.get( arg );  // вот тут и берем собственно из кэша и возвращаем наружу
//       }
//       let rez = func.call( this, arg ); // а если не встречались, придется считать по честному - передаем аргумент в колбэк.
//       // если функция - не просто ф-я, а метод объекта, то при простом вызове без контекста this (т.е. имени объекта)
//       // будет ошибка ( мало ли объектов), поэтому используем не func( arg ), a func.call( this, arg ) - где this - имя
//       // объекта содержащего метод. Хотя с обычными функциями тоже работает :)
//       cash.set( arg, rez );      // аргумент и соответствующий ему результат записываем в кэш
//       console.log( ' Directly ' );
//       return rez;                // и возвращаем наружу
//     };
//   }
//   wdf = casheRator( wdf ); // Вместо функции делаем ту же функцию + ЛО кэшератора
//   console.log( wdf( 3 ) ); //  Directly   9
//   console.log( wdf( 4 ) ); //  Directly   16
//   console.log( wdf( 5 ) ); //  Directly   25
//   console.log( wdf( 3 ) ); //  From cash   9
//   console.log( wdf( 8 ) ); //  Directly   64
//   console.log( wdf( 4 ) ); //  From cash  16
//   console.log( wdf( 5 ) ); //  From cash  25
//   console.log( wdf( 3 ) ); //  From cash   9

// Декоратор. Версия может работать с методами объектов за счет передачи контекста func( this, arg ) и не одним, а 
// любым количеством аргументов за счет func.call/apply( this, ...arguments/arguments )
// function wdf( x, ...y ) { // wdf - wery dificalt function - суммирует все что поступит, сколько бы ни было.
//     return x + y.reduce(( sum, el ) => sum += el );
//   };
//   function casheRator( func, hash ) { // get a function such input parametr
//     const cash = new Map;       // создаем в ЛО функции хранилище для кэша( если она такое уже считала, пусть будет там)
//     return function() {    // эта функция по сути исходная ф-я + некая логическая оболочка ( если че - бери из кэша)
//       const key = hash( arguments ); // создаем ключ для хэш-мапа из набора аргументов
//       if ( cash.has( key ) ) {  // если такие исходные данные (arg) уже встречались, то результат не считаем, а берем из кэша.
//         console.log( ' From cash ' );
//         return cash.get( key );  // вот тут и берем собственно из кэша и возвращаем наружу
//       }
//       let rez = func.call( this, ...arguments );  // а если не встречались, придется считать по честному - передаем аргумент в колбэк.
//       cash.set( key, rez );      // аргумент и соответствующий ему результат записываем в кэш
//       console.log( ' Directly ' );
//       return rez;                // и возвращаем наружу
//     };
//   }
//   function hash( arr ) {             // формирует ключ- строку из набора аргументов, соединяя их запятой (или еще чем :))
//     // arr = Array.from( arr ).join('+'); // почему-то arguments поступил в виде объекта пар { '0':3, '1':3, '2':3 }
//     arr = [].join.call( arr ); // заимствуем у настоящего массива [] метод join и передаем ему аргументы arr
//     console.log( 'key=', arr );
//     return arr;
//   }
//   wdf = casheRator( wdf, hash );       // Вместо функции делаем ту же функцию + ЛО кэшератора
//   console.log( wdf( 3, 3, 3, 3 ) );    //  Directly   12
//   console.log( wdf( 4, 4, 4 ) );       //  Directly   12
//   console.log( wdf( 5, 4, 3, 2, 1 ) ); //  Directly   15
//   console.log( wdf( 3, 2, 1 ) );       //  Directly   6
//   console.log( wdf( 8, 1, 1 ) );       //  Directly   10
//   console.log( wdf( 4, 4, 4 ) );       //  From cash  12
//   console.log( wdf( 5, 5, 5 ) );       //  Directly   15
//   console.log( wdf( 3, 3, 3, 3 ) );    //  From cash  12

// Задача 2.1. Декоратор-шпион ПЕРЕДЕЛАТЬ!!!
// Создайте декоратор spy(func), который должен возвращать обёртку, которая сохраняет все вызовы функции 
// в своём свойстве calls.
// Каждый вызов должен сохраняться как массив аргументов.
// Например:
// function work(a, b) {
//     console.log( a + b ); // произвольная функция или метод
// }
// work = spy(work);
// work(1, 2); // 3
// work(4, 5); // 9
// for (let args of work.calls) {
// console.log( 'call:' + args.join() ); // "call:1,2", "call:4,5"
// }
// function spy( func ) {
//     wrap.calls = [];
//     function wrap() {
//          wrap.calls.push( [...arguments] );
//          //return func.apply( this, arguments ); // фокус пройдет даже если функцию сделать методом какого-то объекта
//          return func( ...arguments ); // но, т.к. контекстом функ является globalThis, то достаточно и так :)
//     };
//     return wrap;
// } // IS_DONE

// Задача 2.2. Задерживающий декоратор
// Создайте декоратор delay(f, ms), который задерживает каждый вызов f на ms миллисекунд. Например:
// function f(x) {
//   console.log(x);
// }
// // // создаём обёртки
// let f3000 = delay(f, 3000);
// let f5000 = delay(f, 5000);
// f3000("test"); // показывает "test" после 1000 мс
// f5000("test"); // показывает "test" после 1500 мс
// // Другими словами, delay(f, ms) возвращает вариант f с «задержкой на ms мс».
// // В приведённом выше коде f – функция с одним аргументом, но ваше решение должно передавать все аргументы и контекст this.
// function delay(f, ms) {
//     return function( ...a ) {
//         setTimeout( () => f.apply( this, a ), ms );
//     }
// } // IS_DONE

// Задача 2.3. Декоратор debounce
// Результатом декоратора debounce(f, ms) должна быть обёртка, которая передаёт вызов f не более одного раза в ms миллисекунд. 
// Другими словами, когда мы вызываем debounce, это гарантирует, что все остальные вызовы будут игнорироваться в течение ms.
// Например:
// let f = debounce(console.log, 1000);
// f(1); // выполняется немедленно
// f(2); // проигнорирован
// setTimeout( () => f(100), 100); // проигнорирован (прошло только 100 мс)
// setTimeout( () => f(1100), 1100); // выполняется
// setTimeout( () => f(1200), 1200); // игнор
// setTimeout( () => f(1300), 1300); // игнор
// setTimeout( () => f(1400), 1400); // игнор
// setTimeout( () => f(1500), 1500); // проигнорирован (прошло только 400 мс от последнего вызова)
// setTimeout( () => f(2101), 2101); // может да, а может нет
// setTimeout( () => f(2102), 2102); // может да, а может нет
// setTimeout( () => f(2150), 2150); // может да, а может нет
// setTimeout( () => f(2200), 2200); // ингнор
// // На практике debounce полезен для функций, которые получают/обновляют данные, и мы знаем, что повторный вызов
// // в течение короткого промежутка времени не даст ничего нового. Так что лучше не тратить на него ресурсы.
// function debounce( func, ms ) {
//     let canRun = true;
//     return function() {
//         if ( !canRun ) {
//             return;
//         } else {
//             canRun = false;
//             setTimeout( () => canRun = true, ms );
//             return func.apply( this, arguments );
//         }
//     } 
// } // IS_DONE

// Задача 2.4. Тормозящий (throttling) декоратор
// Создайте «тормозящий» декоратор throttle(f, ms), который возвращает обёртку, передавая вызов в f не более одного раза
// в ms миллисекунд. Те вызовы, которые попадают в период «торможения», игнорируются.
// Отличие от debounce – если проигнорированный вызов является последним во время «задержки», то он выполняется в конце.
// Давайте рассмотрим реальное применение, чтобы лучше понять это требование и выяснить, откуда оно взято.
// Например, мы хотим отслеживать движения мыши.
// В браузере мы можем объявить функцию, которая будет запускаться при каждом движении указателя и получать его 
// местоположение. Во время активного использования мыши эта функция запускается очень часто, это может происходить 
// около 100 раз в секунду (каждые 10 мс).
// Мы бы хотели обновлять информацию на странице при передвижениях.
// …Но функция обновления update() слишком ресурсоёмкая, чтобы делать это при каждом микродвижении. Да и нет смысла делать 
// обновление чаще, чем один раз в 1000 мс.
// Поэтому мы обернём вызов в декоратор: будем использовать throttle(update, 1000) как функцию, которая будет запускаться 
// при каждом перемещении указателя вместо оригинальной update(). Декоратор будет вызываться часто, но передавать вызов
// в update() максимум раз в 1000 мс.
// Визуально это будет выглядеть вот так:
// Для первого движения указателя декорированный вариант сразу передаёт вызов в update. Это важно, т.к. пользователь сразу
// видит нашу реакцию на его перемещение.
// Затем, когда указатель продолжает движение, в течение 1000 мс ничего не происходит. Декорированный вариант игнорирует вызовы.
// По истечению 1000 мс происходит ещё один вызов update с последними координатами.
// Затем, наконец, указатель где-то останавливается. Декорированный вариант ждёт, пока не истечёт 1000 мс, и затем вызывает
// update с последними координатами. В итоге окончательные координаты указателя тоже обработаны.
// Пример кода:
// function f(a) {
//   console.log(a)
// }
// f1000 передаёт вызовы f максимум раз в 1000 мс
// let f1000 = throttle(f, 1000);
// f1000(1); // показывает 1
// f1000(2); // (ограничение, 1000 мс ещё нет)
// f1000(3); // (ограничение, 1000 мс ещё нет)
// // когда 1000 мс истекли ...
// // ...выводим 3, промежуточное значение 2 было проигнорировано
// P.S. Аргументы и контекст this, переданные в f1000, должны быть переданы в оригинальную f.
// function throttle( func, ms ) {
//     let canRun = true;
//     let lastCall, timerId = 0;
//     return function() {
//         if ( !canRun ) {
//             lastCall = func;
//             clearTimeout( timerId );
//             timerId = setTimeout( () => lastCall.apply( this, arguments ), ms );
//             return;
//         } else {
//             canRun = false;
//             clearTimeout( timerId );
//             setTimeout( () => canRun = true, ms );
//             return func.apply( this, arguments );
//         }
//     } 
// } // IS_DONE
// let f = throttle(console.log, 1000);
// f(1); // выполняется немедленно
// f(2); // проигнорирован
// setTimeout( () => f(100), 100); // проигнорирован (прошло только 100 мс)
// setTimeout( () => f(1100), 1100); // выполняется
// setTimeout( () => f(1200), 1200); // игнор
// setTimeout( () => f(1300), 1300); // игнор
// setTimeout( () => f(1400), 1400); // игнор
// setTimeout( () => f(1500), 1500); // проигнорирован (прошло только 400 мс от последнего вызова)
// setTimeout( () => f(2101), 2101); // может да, а может нет
// setTimeout( () => f(2102), 2102); // может да, а может нет
// setTimeout( () => f(2150), 2150); // может да, а может нет
// setTimeout( () => f(2200), 2200); // ингнор
// setTimeout( () => f(3210), 3210); // ?