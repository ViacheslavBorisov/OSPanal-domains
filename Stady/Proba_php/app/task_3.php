<!DOCTYPE html>
    <html>
	    <head>
		    <title> Задание 3. </title>
			<link type="text/css" rel="stylesheet" href="http://stady/Proba_php/php_style.css"/>
            <meta charset="utf-8"/>
		</head>
		<body>
		    <h2 class="task_name"> Задание 2. </h2> <h3> <a href="http://stady/Proba_php/Proba_php.php"> НА ГЛАВНУЮ </a> </h3>
			<div class="task_block">
			<?php
				    echo <<<test2
					Разработайте программу, которая из чисел 20..45 находила те, которые делятся на 5 и найдите<br>
					сумму этих чисел.<br>
					Рекомендуется использовать функцию fmod для определения "делится число" или "не делится".
test2;
			?>
			<br><br>
			<form method="GET" action="http://stady/Proba_php/app/task_3.php">
			    Введите границы диапазона чисел: <br>
				от <input type="text" name="border_1">
				до <input type="text" name="border_2">
				<br> и делитель: <input type="text" name="separ"> <br>
				<input type="submit" value="Calculate">
				<input type="reset" value="Clean">
			</form>
			<?php
    			if($_SERVER['REQUEST_METHOD'] == 'GET') {
					echo '<div class="task_block" style="background-color: brown"> <div class="anser_block">';
					$correct = 1;   //Маркер корректности ввода ВСЕХ данных во ВСЕХ полях
	    			for($i = 1; $i <= 3; ++$i) { //Проверка вводимых данных: все ли они цифры
						if($i == 1) { $input_data = $_GET['border_1']; $aria_name = "от"; }
					    if($i == 2) { $input_data = $_GET['border_2']; $aria_name = "до"; }
					    if($i == 3) { $input_data = $_GET['separ']; $aria_name = "делитель"; }
						$len_str = strlen($input_data);
						$input_array = str_split($input_data); //Начало блока проверки введенных данных.
						if($len_str > 0) {  //Данный оператор можно заменить на "обязательность заполнения" полей в форме.
                            $chislo = 1;
							$l = 0; //Счетчик индексов некорректных элементов
    						for($j = 0; $j <= ($len_str - 1); ++$j) {  //Перебираем символы входящие в энное поле
								$cifra = 0;
							    for($k = 0; $k <= 9; ++$k) {           //Сравниваем их с цифрами от 0 до 9
								    if($input_array[$j] == "$k") $cifra = 1;//$cifra = 1 -> Символ совпал с цифрой
				                }
								if($cifra == 0) { $index_corrupt[$l] = $j; ++$l;} 
									//" символ ",$input_array[$j]," на позиции ",$j + 1," не корректен!<br>";
                                $chislo = $chislo * $cifra; // $chislo = 1 -> все символы во энном поле формы - цифры
                           	}
							if($chislo == 1) {
								if ($i == 1) { settype($input_data, integer); $ot = $input_data; }
                                if ($i == 2) { settype($input_data, integer); $do = $input_data; }
                                if ($i == 3) { settype($input_data, integer); $delitel = $input_data; }									
							    } else {
							        echo 'В поле "<span class="anser_task">',$aria_name,'</span>" в исходных данных: ';
									$l = 0;
									for ($j = 0; $j <= ($len_str - 1); ++$j) {
										if($j == $index_corrupt[$l]) {
										    $l++;
                                            echo '<span style="color: red; font-size: 140%">',$input_array[$j],"</span>";											
										} else  echo '<span class="anser_data">',$input_array[$j],"</span>";
									}
									echo ' введен <span style="color: red">некорректный символ</span> или пробел.<br>';
							}		
                            $pole_ok++; //Одно из полей чем-то заполнено - после 3 циклов - в идеале все три.
						}
						$correct = $correct * $chislo; //В очередном поле корректные данные. В идеале - во всех 3х.
					}					//Конец блока проверки входных данных
					if($pole_ok == 0) echo '<p style="text-align: center; color: lightgray; font-weight: bold; margin: 0px">ОБЛАСТЬ ВЫВОДА РЕЗУЛЬТАТА</span>';
					if(($pole_ok > 0) and ($pole_ok < 3)) echo '<p class="anser_rez">Не все поля заполнены!</p>';
					if(($correct == 1) and ($pole_ok == 3)) { //Данные верны. Начало блока вычислений.
					    if($ot < $do) { $min = $ot; $max = $do; } else { $min = $do; $max = $ot; }
					    echo 'В диапазоне от.. <span class="anser_task">',$min, '</span> ..до.. <span class="anser_task">',$max, '</span> ..на.. <span class="anser_task">', $delitel, "</span> ..нацело делятся числа:<br>";
	                    $i = 0;
						while($min <= $max) {
						    if(fmod($min, $delitel) == 0) {
						        $summa = $summa + $min;
					            echo '<span class="anser_data"> ',$min,", </span>";
                                $i = 1;								
					        }
                             $min++;							
					    }
						if($i == 1) { echo '<br>их сумма равна: <span class="anser_rez">' ,$summa,"</span>" ; } 
					        else { echo '<br><span class="anser_rez">Такие числа отсутствуют</span>'; }
					}
					echo "</div> </div>";
		        }
			?>
			<p class="task_name"> Текст программы. Вариант "Местный". <br>				
			<img class="task_block" src="http://stady/Proba_php/img/task_3.png"/> 
			</div>
			<p style="color: blue"> ПЛАН СРАЖЕНИЯ :)<br>
1. Создать форму, в которой получаем: границы диапазона чисел (2 поля) и делитель (третье поле).<br>
2. Погуглить: можно ли передавать формами числовые переменные (целые и с плавающей точкой), если да - то как проверить относятся ли полученные данные 
к данному классу.<br>
3. Получить данные от формы (метод GET - с POSTом успею еще наиграться: не все сразу :)). Проверить их на отсутствие символов, не являющихся цифрами.
По необходимости преобразовать в цифровую форму.<br>
4. Определить, какая из границ диапазона верхняя, а какая нижняя.<br>
5. Определить, не является ли значение верхней границы диапазона меньшим, чем делитель. Выдать сообщение "Сумма = 0".<br>
6. Задать цикл от нижней, до верхней границы с шагом "1", где при FMOD(делимое, делитель)=0, SUMMA = SUMMA + делимое (SUMMA += делимое).<br>
7. Красиво вывести результат: В диапазоне от ... на ... делятся числа: ..., ..., их сумма равна:....<br>
			</p>
			<p style="color: red"> ПРОБЛЕММЫ: <br>
1. Часа 3-4 определял длину массива (отладка. проверка корректности входных данных). Наш великолепный оператор COUNT(), 
оказывается <strong>даже при пустых полях</strong>, СУКА!!!, ВЫДАЕТ ЗНАЧЕНИЕ <strong>ЕДЕНИЦА</strong>.<br> 
2. Запись вида: $var = settype($var1, integer); - некорректна, т.к. ЗДЕСЬ СНАЧАЛА ПРОИЗВОДИТСЯ ПРИСВАИВАНИЕ, а потом уже преобразование типа данных, что конечно странно. <br>
			</p>
			<p style="color: brown"> НАБЛЮДЕНИЯ: <br>
1. Наблюдается полный ППЦ, при отладке: проверке корректности входных данных :)<br>
2. Для нескольких пробелов подряд используют сущность (& n b s p) - без скобок и пробелов - ЭТО ПРОБЕЛ :))<br>
3. В незаполненном массиве, преобразованном из пустой (полученной из пустого поля формы) строки (strlen()=0), при помощи функции
str_split(), есть как минимум один элемент $array[1]="Array", поэтому мерять число символов во входной строке (проверять поле на "заполненность")
функцией count() - дело неблагодарное. Она как минимум покаже ОДИН ЭЛЕМЕНТ МАССИВА.<br>
4. В цикле FOR с обработкой элементов массива глубоко пофиг ПРЕ- или ПОСТ - декримент ты используешь. Главное помнить, что нумерация элементов
начинается с нуля, а подсчет количества элементов (функция strlen()) - с единицы, то есть цикл должен идти (от 0 до strlen()-1)<br>
5. Строка символов, состоящая из цифр, при преобразовании типа к целому - СТАНОВИТСЯ ЧИСЛОМ!!!. Нули и пробелы в начале числа - игнорируются.<br>
6. Также игнорируются все цифры, стоящие после символа не являющегося цифрой. Если такой символ стоит в начале данных, то преобразование вида:
$var=(int)$var_1 дает: $var = 0.<br>Пример: $var_1= "479" -> $var= 479 <br> $var_1 = "4a9" -> $var = 4<br>$var_1 = "+79" -> $var = 0<br>
			</p>
			<p style="color: green"> РЕШЕНИЯ: <br>
1. Как-нибудь, когда-нибудь посмотреть, как эта фигня работает, а пока пользоваться старым, добрым <strong>strlen()</strong>.<br>
2. Разбиение входной строки на массив нужно ТОЛЬКО для проверки отдельных символов (надо посмотреть: нет ли такого оператора), а так,
в случае заведомо корректного ввода, проще преобразовать в целое всю строку входных данных - заодно и нули в первых позициях отсечет.
 НАДО ПОСМОТРЕТЬ РАБОТУ С ФОРМАМИ.<br>
3. Запись вида: $var = settype($var1, integer); - некорректна, т.к. ЗДЕСЬ СНАЧАЛА ПРОИЗВОДИТСЯ ПРИСВАИВАНИЕ, а потом уже преобразование типа данных,
что конечно странно. Т.о. в $var попадает значение "1" (там же одна строка? :)). Правильно использовать:<br>settype($var1, integer);<br>$var = $var1;<br>
			</p>
		</body>
	</html>