< 1. В регулярных выражениях с использованием кириллицы весьма лояльное отношение к 
    НЕПРОПИСАННОЙ ВНУТРЕННЕЙ КОДИРОВКЕ, (по умолчанию "ISO-8859-1"),
	несовпадению кодировки внутренней и mb_regex_encoding() - специально установленной 
	для работы с регулярными выражениями, (по умолчанию "EUC-JP"), НО(!!!):
        - Без установки внутренней UTF-8 функция mb_strlen() - УДВАИВАЕТ число символов в КИРИЛЛИЦЕ;
          = и вообще отказываются работать большинство mb_-функций не связаных с РВ:
            $fio = mb_convert_case(mb_strtolower($fio), MB_CASE_TITLE) - выдает кракозябры :);
        - Использовать только mb_ereg_match() (но не preg_match() - никак не обслуживает КИРИЛЛИЦУ);
        - mb_ereg_match() НЕ ПЕРЕВАРИВАЕТ СЛЕШИ ("/"), ограничивающие регулярное выражение, но, если
          писать без них (просто в кавычках "^..........$") то все нормально;
        - В КИРИЛЛИЦЕ (УТФ-8) в подмножество "всех букв" - \w - попадают так же ЦИФРЫ, т.о. чтобы
          точно определить записаны в строке ТОЛЬКО слова надо ФИГ ЗНАЕТ КАК НАПРЯГАТЬСЯ!!! :)
          Задавайте себе нормально интервалы и не парьтесь :)).
        - Если 2 раза подряд (по ошибке) перекодировать путь, содержащий папку, имя которой задано на
          кирилице: MB_CONVERT_ENCODING($name, "cp-1251", "UTF-8"); // и еще раз:		
                    MB_CONVERT_ENCODING($name, "cp-1251", "UTF-8"); -
          ИМЯ ПАПКИ (или файла) ВООБЩЕ ИСЧЕЗАЕТ! (СЪЕДАЕТСЯ).
		  
 2. ОТЛИЧНЫЕ примеры использования РВ: http://htmlweb.ru/php/example/preg.php (да и вообще сайт интересный:)		  

 3. MB_EREG_REPLACE:
    Рабочий шаблон для ФИО из пяти слов: 
    (^[^\s]+)\s+([А-Я]?)[\w]*[\s]*([А-Я]?)[\w]*[\s]*([А-Я]?)[\w]*[\s]*([А-Я]?)[\w]*[\s]*
    Функция вывода строки:
    \1 \2. \3. \4. \5.
    Оказалось ПОЛНОЙ ЧУШЬЮ - НЕ РАЦИОНАЛЬНО!
    Функция MB_EREG_REPLACE(шаблон, заменяющие, строка) работает так:
        - "строка" состоит из "заменяемых" и "не заменяемых" частей в зависимости от соответствия "шаблону";
        - в результате выполнения функции выдаются:
          = части "строки" НЕ ПОДОШЕДШИЕ ПОД "ШАБЛОН";
          = затем части "строки" подошедшие под "ШАБЛОН", которые заменяются по правилам "заменяющие":
            == ВСЕ ПОДОШЕДШЕЕ ПОД "ШАБЛОН" - ЗАМЕНЯЕТСЯ;
            == переменные, предназначенные для вывода, беруться в круглые скобки ();
            == в поле "заменяющие" отображение этих переменных обозначается как \1(\2\3....\9) в зависимости
               от того, какие по счету () обрабатываются;
            == если в "строке" под "шаблон" подходит НЕСКОЛЬКО участков текста, то, при наличие выделенных ()
               элементов они заносятся в один и тот же параметр \1 или \N (смотря какой он оказался по счету
               до возникновения ЦИКЛА перебора участков строки);
    N.B.- При необходимости писать "шаблон", а особенно, "заменяющие" прямо в функции ( а не вводить их через 
          переменные), писать их надо в СТРОГИХ (одиночных) КАВЫЧКАХ.
		  ИЛИ ЭКРАНИРУЙ ОБРАТНЫЙ СЛЭШ \\1, ИДИОТ!!!! :)))))))))))
          $input = mb_ereg_replace('\s+([А-ЯA-Z])\w*', ' \1.', $input);
    ПРИМЕР:
        "шла себе   саша         по  шоссе   и сосала    что попало"
      шаблон:
        "\s+([А-Я])\w*"
      заменяющие:
        " \1."	
      результат:
        "Шла С. С. П. Ш. И. С. Ч. П."
      Работа:
        - Первый элемент "Шла" выдается весь как есть, т.к. НЕ ПОПАДАЕТ ПОД ШАБЛОН (перед ним нет пробела);
        - последующие элементы (все соответствуют шаблону) - полностью удаляются (заменяются);
        - вместо них (на их места) по замене через параметр-ссылку \1 по очереди (идет перебор - обработка строки)
          попадают элементы, вычленные круглыми скобками шаблона, предваренные пробелом и законченые точкой.
		  
 3a. PREG_REPLACE_CALLBACK('шаблон', 'имя функции, вычисляющей "заменитель"', 'исходная строка');
     function ИМЯ_ТАКОЕ_ЖЕ_КАК_В_PREG_REPLACE_CALLBACK($matches-массив подмасок(\1-\9-зависит от шаблона)) {
	 ... какие-то вычисления ...
	 return $matches[1-9];
	 }
	 Функция вызывается столько раз, сколько совпадений шаблона происходит с исходной строкой.
     MB_EREG_REPLACE_CALLBACK - у меня почему-то не пошла. Говорит, что используется "неизвестная функция".

 4. MB_EREG('шаблон', 'В чем искать', $массив в который попадают совпавшие части), равно: 
    = "1", если есть совпадения, но параметр $массив не указан (не обязательный параметр). 
      Совпадает с ПУСТОЙ СТРОКОЙ;
    = длине совпавшей части в байтах, если $массив указан;
    = FALSE, если совпадения не найдены или произошла ошибка;
    = $массив[0] - вся совпавшая строка, $массив[1] - часть, заключенная в первые скобки и т.д;
    
         
	