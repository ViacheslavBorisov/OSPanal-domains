<                              	          РАБОТА С ФАЙЛАМИ:
                                   ПОЛУЧИТЬ ДОСТУП К ФАЙЛУ (КАТАЛОГУ):
1. fopen('путь и имя файла', 'режим открытия (r,r+,a,a+,w,w+)') - создает ДЕСКРИПТОР файла 
   (№ потока, по которому в последствии будут осуществляться обращения к файлу).  
r,  r+   --- ЧТЕНИЕ, дозапись в НАЧАЛО файла.                  Запись ПОВЕРХ ПРЕДЫДУЩЕЙ ИНФОРМАЦИИ.  
a, a+  --- доЗАПИСЬ, чтение в КОНЕЦ файла. СОЗДАНИЕ файла.     Запись ПОСЛЕ ПРЕДЫДУЩЕЙ ИНФОРМАЦИИ.
w, w+ --- переЗАПИСЬ, чтение с НАЧАЛА файла. СОЗДАНИЕ файла.   Стирает СТАРЫЙ ФАЙЛ.

mode	Описание
'r'	 Открывает файл только для чтения; помещает указатель в начало файла.
'r+' Открывает файл для чтения и записи; помещает указатель в начало файла.
'w'	 Открывает файл только для записи; помещает указатель в начало файла и обрезает файл до нулевой длины. 
     Если файл не существует - пробует его создать.
'w+' Открывает файл для чтения и записи; помещает указатель в начало файла и обрезает файл до нулевой длины. 
     Если файл не существует - пытается его создать.
'a'	 Открывает файл только для записи; помещает указатель в конец файла. 
     Если файл не существует - пытается его создать.
'a+' Открывает файл для чтения и записи; помещает указатель в конец файла. 
     Если файл не существует - пытается его создать.
'x'	 Создаёт и открывает только для записи; помещает указатель в начало файла. 
     Если файл уже существует, вызов fopen() закончится неудачей, вернёт FALSE и выдаст ошибку уровня E_WARNING. 
     Если файл не существует, попытается его создать. Это эквивалентно указанию флагов O_EXCL|O_CREAT для 
     внутреннего системного вызова open(2).
'x+' Создаёт и открывает для чтения и записи; иначе имеет то же поведение что и'x'.
'c'	 Открывает файл только для записи. Если файл не существует, то он создается. 
     Если же файл существует, то он не обрезается (в отличии от 'w'), и вызов к этой функции не вызывает ошибку 
     (также как и в случае с 'x'). Указатель на файл будет установлен на начало файла. Это может быть полезно 
     при желании заблокировать файл (смотри flock()) перед изменением, так как использование 'w' может обрезать 
     файл еще до того как была получена блокировка (если вы желаете обрезать файл, можно использовать функцию 
     ftruncate() после запроса на блокировку).
'c+' Открывает файл для чтения и записи; иначе имеет то же поведение, что и 'c'.
     
2. $a = fopen();   - теперь $a - дескриптор указанного в fopen() файла.
3. fclose($a); - закрыть файл с дескриптором $a.
4. $a = opendir('путь к каталогу')==FALSE, если не открылся, ДЕСКРИПТОР каталога, если открылся.
5. closedir('дескриптор каталога');

                                                НАВИГАЦИЯ:
1. chdir('путь и имя каталога, который нужно сделать текущим'); - сменить директорию.
            FALSE - если не удалось, TRUE - если удалось.
2. getcwd(); - узнать имя текущего каталога.

               
                                    ОБРАБОТКА ДАННЫХ В ФАЙЛЕ (КАТАЛОГЕ).                                      
---- Не требует предварительного открытия (БЕЗ ДЕСКРИПТОРА):
1. file('путь и имя файла') == содержимое файла в виде МАССИВА СТРОК.
2. file_get_contents('путь и имя файла') == содержимое файла в виде ОДНОЙ СТРОКИ.
3. file_put_contents('путь и имя файла', 'записываемая строка');
    - пишет ПОВЕРХ ПРЕДЫДУЩЕЙ информации.
4. scandir('путь к каталогу'); == массив - список всех элементов каталога. 

---- После получения дескриптора:
1. fgets(дескриптор, количество байт для считывания) == содержание файла от текущего до конца
   строки (если конец строки раньше, чем количество байт для считывания) или в объеме,  указанном в параметре
   "количество считываемых байт".
2. fputs('дескриптор', 'записываемая строка');
3. feof('дескриптор') == TRUE - если файл закончился, FALSE - если не закончился.
4. readdir('дескриптор каталога'); - считывает очередной ЭЛЕМЕНТ каталога, возвращает дескриптор (или имя ХЗ) 
   следующего элемента. Если дескриптор не указан,  используется  последний из открытых opendir();

                                       	ПРОВЕРИТЬ, ЧЕМ ЯВЛЯЕТСЯ ЭЛЕМЕНТ КАТАЛОГА:
1. is_dir('путь и имя'); - папкой ?
2   is_file('путь и имя'); - файлом ?
3.  is_link('путь и имя'); - иконкой ?
4. filetype('имя файла'); == fifo, char, dir, block, link, file или unknown. 
5. stat() - Получает информацию о файле(дата создания, владелец) в виде массива.
6. lstat() - Получает информацию о файле или символической ссылке
7. file_exists() - Проверяет, существует ли файл или директория
8. is_writable() - Проверяет возможность записи в файл
9. is_readable() - Проверяет возможность чтения из файла
10. is_executable() - Выясняет, является файл выполнимым
11. filectime(), fileatime(), filemtime(), fileinode(), filegroup(), fileowner(), filesize(), 
      filetype(), fileperms() -       возвращают информацию о файле.
11а. stat('имя файла(или путь -  ХЗ)') - дает информацию о файле:
Числовой	Ассоциативный	   Описание
0	        dev	                   номер устройства
1	        ino	                   номер inode *
2	        mode	           режим защиты inode
3	        nlink	                   количество ссылок
4	        uid	                   userid владельца *
5	        gid	                   groupid владельца *
6	        rdev	                   тип устройства, если устройство inode
7	        size	                   размер в байтах
8	        atime	           время последнего доступа (временная метка Unix)
9	        mtime	           время последней модификации (временная метка Unix)
10	        ctime	           время последнего изменения inode (временная метка Unix)
11	        blksize	           размер блока ввода-вывода файловой системы **
12	        blocks	           количество используемых 512-байтных блоков **

                              РАБОТА С ФАЙЛОМ, УЧИТЫВАЯ ТЕКУЩИЕ ИЗМЕНЕНИЯ:
PHP работает не непосредственно с файлами на диске, а с их копиями в кэше. Если внести изменения в файл, 
а потом попытаться работать с учетом этих изменений, может случиться облом, 
т.к. КОПИЯ-то ОСТАЛАСЬ ПРЕЖНЕЙ. Чтобы избежать этого:
 сlearstatcache()-очищает кэш состояния файлов. Если  производятся какие-то изменения в файлах скриптом,
а потом работа, основывается на этих изменениях, то после изменений вызывают эту функцию. 
Иначе ваши изменения могут быть не обнаружены. 

                                        УДАЛИТЬ ФАЙЛ:
1. unlink('имя файла (или путь - ХЗ');
