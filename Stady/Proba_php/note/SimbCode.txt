
 //ЗАДАНИЕ _6. СОЗДАНИЕ СОКРАЩЕННОГО ВАРИАНТА ФИО,
      //Вводим: Иванов Иван Петрович и нам выводит: Иванов И. П.
      //Сверхзадача: обработать строку так, чтобы не разбивать ее на подстроки, а тем более без
      //использования массивов!...
	  //Более простые варианты решения: STR_WORD_COUNT(строка, 1(2 или 3)) - сразу определит, состоит
	  //ли строка из слов, и разобъет ее на массив.
	  // Пригодится: https://php.net/manual/ru/function.strpos.php
	  // https://php.net/manual/ru/language.operators.string.php
	  // https://php.net/manual/ru/function.strstr.php
	  // https://php.net/manual/ru/function.substr-replace.php
	  // https://php.net/manual/ru/function.ucwords.php
	  // Написать функцию замены строчных букв на заглавные для кирилицы.
	  //Когда вводишь данные из формы, каждый символ - 1 элемент при использовании str_split,
	  //а когда набиваешь прямо в файле - 2!!! (UTF-8 и cp1251 "дружат" аж до кровавых соплей :)
	  /* 
	  5.15.3. Функции для работы с символами
chr(<Код символа>) возвращает символ по указанному коду:
echo chr(81); // Выведет: Q
ord(<Символ>) возвращает код указанного символа:
echo ord("Q"); // Выведет: 81

void var_dump ( mixed $expression [, mixed $... ] )
Функция отображает структурированную информацию об одном или нескольких выражениях, включая их тип и значение. 
Массивы и объекты анализируются рекурсивно с разным отступом у значений для визуального отображения структуры.

В конфигурации моего компа - сервера исходные данные на кирилице из формы попадают в тело программы в виде УТФ-81
(собственно, как и прописано), 2бита на символ (хотя пробелы и, думаю, другие знаки препинания - ! бит),
 а вот латиница - в виде АСКИ (1 байт на символ), что странно!!!!!!???????
Есть возможность перекодирования и т.д. ОБРАТИТЬ ВНИМАНИЕ НА ГРУППУ ФУНКЦИЙ mb_xxx_xxx. Плюс mb-detect-encoding()
При указании правильной кодировки могут эффективно работать с кириллицей.

mb_convert_case - Универсально, для юникода (УТФ-8) преобразует регистр символов в строке.
ВСЕ ФУНКЦИИ ДЛЯ РАБОТЫ С МНОГОБАЙТОВЫМИ СТРОКАМИ ЗДЕСЬ: https://php.net/manual/ru/ref.mbstring.php (ДОКИ PHP)

Оказывается есть внутренняя "кодировка по умолчанию":  В HTML ISO-8859-1 является кодировкой по умолчанию 
(в XHTML, однако, кодировкой по умолчанию является UTF-8). Поэтому при работе с КИРИЛЛИЦЕЙ ОЧЕНЬ ВОЖНО ЗАДАТЬ
 mb_internal_encoding("UTF-8"), чтобы избежать неоднозначности.
 
 Большинство браузеров не различают ISO-8859-1 и Windows-1252 — фактически, и в том, и в другом случае они
 отображают текст как Windows-1252. В проекте стандарта HTML 5 предписывается показывать ISO-8859-1 как 
 Windows-1252. Кодировки серии ISO 8859 применяются главным образом на юниксоподобных системах, а также для 
 кодирования веб-страниц (поскольку большинство веб-серверов используют UNIX).
  Многие многобайтовые кодировки определяют кодировку ASCII как свое подмножество.
  
 Пытаясь обратиться к какому-либо символу строки по индексу - при любом раскладе, вне зависимости от кодировки
 мы обращаемся к очередному БИТУ, а НЕ СИМВОЛУ!!!. Таким образом преобразовывать строки в массивы для обработки,
 если нет необходимости работать ИМЕННО С БИТАМИ - УЩЕРБНЫЙ ПОДХОД!!!


function TestPHP($input) {
    function BigLitera($smol_litera) { // Замена строчных букв на заглавные. Кирилица.
        $strochn = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя';
        $zaglavn = 'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ';
        $strochn = str_split($strochn, 2);
        $zaglavn = str_split($zaglavn, 2);
        for($i = 0; $i <= count($strochn); $i++) {
            if($smol_litera == $strochn[$i]) $litera_num = $i;
        }
    return $zaglavn[$litera_num];		
    }
	
ОЧЕНЬ заинтересовал способ создания КРАСИВЫХ checkbox-ов без джаваскриптов: 
https://www.kobzarev.com/makeup/dedovskiy-sposob-kastomizatsii-chekboksov-radioknopok-na-css.html

Код HTML5

<label id="check"><input type="checkbox" name="first" class="check"><span></span></label>
<label id="check1"><input type="checkbox" name="second" class="check1"><span></span></label>


Код CSS

label #check{
 width: 29px;
 height: 27px; 
 display: block; 
 position: relative; 
}
 
input[type="checkbox"] + span {
 position: absolute; /* Абсолютное позиционирование */
 left: 203px; top: 370px;
 width: 100%; height: 100%;
 background: url(image/check.png) no-repeat; /* Фоновый рисунок */
 cursor: pointer; /* Курсор в виде руки */
}
 
.check{
margin-left:40px;
}
 
input[type="checkbox"]:checked + span   {
 background:url(image/check1.png) no-repeat;
 background-position:-1px -2px;
}
*/

